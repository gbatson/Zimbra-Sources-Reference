/* Generated By:JavaCC: Do not edit this line. ZimbraQueryParser.java */
package com.zimbra.cs.index.queryparser;

import java.util.TimeZone;
import java.util.Locale;

import com.zimbra.cs.index.*;
import com.zimbra.cs.mailbox.Mailbox;
import com.zimbra.common.service.ServiceException;
import com.zimbra.cs.service.util.ItemId;
import com.zimbra.cs.mailbox.MailServiceException;
import com.zimbra.common.util.ZimbraLog;

import org.apache.lucene.analysis.Analyzer;

import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;

public final class ZimbraQueryParser implements ZimbraQueryParserConstants {

    private static HashMap<String, Integer>  sFolderStrMap;

    private static abstract class GetQueryCallback {
        public abstract ZimbraQuery.BaseQuery execute(Mailbox mailbox, Analyzer analyzer, int modifier) throws ServiceException;
    }

        private int mDefaultField;

    private static HashMap<String, GetQueryCallback> sIsStrMap;

    static {
        /* Well-known folder name string map */
        sFolderStrMap = new HashMap<String, Integer>();
        sFolderStrMap.put("inbox",    new Integer(Mailbox.ID_FOLDER_INBOX));
        sFolderStrMap.put("trash",    new Integer(Mailbox.ID_FOLDER_TRASH));
        sFolderStrMap.put("junk",     new Integer(Mailbox.ID_FOLDER_SPAM));
        sFolderStrMap.put("sent",     new Integer(Mailbox.ID_FOLDER_SENT));
        sFolderStrMap.put("drafts",   new Integer(Mailbox.ID_FOLDER_DRAFTS));
        sFolderStrMap.put("contacts", new Integer(Mailbox.ID_FOLDER_CONTACTS));

        /* is: string map */
        sIsStrMap = new HashMap<String, GetQueryCallback>();

        // expressing this in java is soooo ugly.... <sigh>
        sIsStrMap.put("read",
                      new GetQueryCallback() { public ZimbraQuery.BaseQuery execute(Mailbox mbx, Analyzer analyze, int modifier) throws ServiceException {
                          return new ZimbraQuery.ReadQuery(mbx, analyze, modifier, true);
                      } } );

        sIsStrMap.put("unread",
                      new GetQueryCallback() { public ZimbraQuery.BaseQuery execute(Mailbox mbx, Analyzer analyze, int modifier) throws ServiceException {
                          return new ZimbraQuery.ReadQuery(mbx, analyze, modifier, false);
                      } } );

        sIsStrMap.put("flagged",
                      new GetQueryCallback() { public ZimbraQuery.BaseQuery execute(Mailbox mbx, Analyzer analyze, int modifier) throws ServiceException {
                          return new ZimbraQuery.FlaggedQuery(mbx, analyze, modifier, true);
                      } } );

        sIsStrMap.put("unflagged",
                      new GetQueryCallback() { public ZimbraQuery.BaseQuery execute(Mailbox mbx, Analyzer analyze, int modifier) throws ServiceException {
                              return new ZimbraQuery.FlaggedQuery(mbx, analyze, modifier, false);
                      } } );

        sIsStrMap.put("draft",
                      new GetQueryCallback() { public ZimbraQuery.BaseQuery execute(Mailbox mbx, Analyzer analyze, int modifier) throws ServiceException {
                              return new ZimbraQuery.DraftQuery(mbx, analyze, modifier, true);
                      } } );

        sIsStrMap.put("received",
                      new GetQueryCallback() { public ZimbraQuery.BaseQuery execute(Mailbox mbx, Analyzer analyze, int modifier) throws ServiceException {
                          return new ZimbraQuery.SentQuery(mbx, analyze, modifier, false);
                      } } );

        sIsStrMap.put("replied",
                      new GetQueryCallback() { public ZimbraQuery.BaseQuery execute(Mailbox mbx, Analyzer analyze, int modifier) throws ServiceException {
                          return new ZimbraQuery.RepliedQuery(mbx, analyze, modifier, true);
                      } } );

        sIsStrMap.put("unreplied",
                      new GetQueryCallback() { public ZimbraQuery.BaseQuery execute(Mailbox mbx, Analyzer analyze, int modifier) throws ServiceException {
                          return new ZimbraQuery.RepliedQuery(mbx, analyze, modifier, false);
                      } } );

        sIsStrMap.put("forwarded",
                      new GetQueryCallback() { public ZimbraQuery.BaseQuery execute(Mailbox mbx, Analyzer analyze, int modifier) throws ServiceException {
                          return new ZimbraQuery.ForwardedQuery(mbx, analyze, modifier, true);
                      } } );

        sIsStrMap.put("unforwarded",
                      new GetQueryCallback() { public ZimbraQuery.BaseQuery execute(Mailbox mbx, Analyzer analyze, int modifier) throws ServiceException {
                          return new ZimbraQuery.ForwardedQuery(mbx, analyze, modifier, false);
                      } } );

        sIsStrMap.put("invite",
                      new GetQueryCallback() { public ZimbraQuery.BaseQuery execute(Mailbox mbx, Analyzer analyze, int modifier) throws ServiceException {
                          return new ZimbraQuery.IsInviteQuery(mbx, analyze, modifier, true);
                      } } );

        sIsStrMap.put("anywhere",
                      new GetQueryCallback() { public ZimbraQuery.BaseQuery execute(Mailbox mbx, Analyzer analyze, int modifier) throws ServiceException {
                          return ZimbraQuery.InQuery.Create(mbx, analyze, modifier, ZimbraQuery.InQuery.IN_ANY_FOLDER, false);
                      } } );

        sIsStrMap.put("local",
                      new GetQueryCallback() { public ZimbraQuery.BaseQuery execute(Mailbox mbx, Analyzer analyze, int modifier) throws ServiceException {
                          return ZimbraQuery.InQuery.Create(mbx, analyze, modifier, ZimbraQuery.InQuery.IN_LOCAL_FOLDER, false);
                      } } );

        sIsStrMap.put("remote",
                      new GetQueryCallback() { public ZimbraQuery.BaseQuery execute(Mailbox mbx, Analyzer analyze, int modifier) throws ServiceException {
                          return ZimbraQuery.InQuery.Create(mbx, analyze, modifier, ZimbraQuery.InQuery.IN_REMOTE_FOLDER, true);
                      } } );

        sIsStrMap.put("solo",
                      new GetQueryCallback() { public ZimbraQuery.BaseQuery execute(Mailbox mbx, Analyzer analyze, int modifier) throws ServiceException {
                          return ZimbraQuery.ConvCountQuery.create(mbx, analyze, modifier, ZimbraQueryParser.CONV_COUNT, "1");
                      } } );

        sIsStrMap.put("sent",  /* sent by me */
                      new GetQueryCallback() { public ZimbraQuery.BaseQuery execute(Mailbox mbx, Analyzer analyze, int modifier) throws ServiceException {
                          return new ZimbraQuery.SentQuery(mbx, analyze, modifier, true);
                      } } );

        sIsStrMap.put("tome",
                      new GetQueryCallback() { public ZimbraQuery.BaseQuery execute(Mailbox mbx, Analyzer analyze, int modifier) throws ServiceException {
                          return ZimbraQuery.MeQuery.create(mbx, analyze, modifier, ZimbraQuery.ADDR_BITMASK_TO);
                      } } );

        sIsStrMap.put("fromme", /* sent by me */
                      new GetQueryCallback() { public ZimbraQuery.BaseQuery execute(Mailbox mbx, Analyzer analyze, int modifier) throws ServiceException {
                          return new ZimbraQuery.SentQuery(mbx, analyze, modifier, true);
                      } } );

        sIsStrMap.put("ccme",
                      new GetQueryCallback() { public ZimbraQuery.BaseQuery execute(Mailbox mbx, Analyzer analyze, int modifier) throws ServiceException {
                          return ZimbraQuery.MeQuery.create(mbx, analyze, modifier, ZimbraQuery.ADDR_BITMASK_CC);
                      } } );

        sIsStrMap.put("tofromme",
                      new GetQueryCallback() { public ZimbraQuery.BaseQuery execute(Mailbox mbx, Analyzer analyze, int modifier) throws ServiceException {
                          return ZimbraQuery.MeQuery.create(mbx, analyze, modifier, ZimbraQuery.ADDR_BITMASK_TO | ZimbraQuery.ADDR_BITMASK_FROM);
                      } } );

        sIsStrMap.put("toccme",
                      new GetQueryCallback() { public ZimbraQuery.BaseQuery execute(Mailbox mbx, Analyzer analyze, int modifier) throws ServiceException {
                          return ZimbraQuery.MeQuery.create(mbx, analyze, modifier, ZimbraQuery.ADDR_BITMASK_TO | ZimbraQuery.ADDR_BITMASK_CC);
                      } } );

        sIsStrMap.put("fromccme",
                      new GetQueryCallback() { public ZimbraQuery.BaseQuery execute(Mailbox mbx, Analyzer analyze, int modifier) throws ServiceException {
                          return ZimbraQuery.MeQuery.create(mbx, analyze, modifier, ZimbraQuery.ADDR_BITMASK_FROM | ZimbraQuery.ADDR_BITMASK_CC);
                      } } );

        sIsStrMap.put("tofromccme",
                      new GetQueryCallback() { public ZimbraQuery.BaseQuery execute(Mailbox mbx, Analyzer analyze, int modifier) throws ServiceException {
                          return ZimbraQuery.MeQuery.create(mbx, analyze, modifier, ZimbraQuery.ADDR_BITMASK_TO | ZimbraQuery.ADDR_BITMASK_FROM | ZimbraQuery.ADDR_BITMASK_CC);
                      } } );
    }

    public ZimbraQuery.BaseQuery GetFieldQuery(int modifier, int target, String targetImg, String tok) throws ParseException, ServiceException, MailServiceException
    {
        return ZimbraQuery.FieldQuery.Create(mMailbox, mAnalyzer, modifier,target,targetImg, tok);
    }

    public static final ParseException parseException(String s, String code, Token t) throws ParseException {
       ParseException pe = new ParseException(s, code);
       pe.currentToken = t;
       return pe;
    }


    public ZimbraQuery.BaseQuery GetQuery(int modifier, int target, String tok, Token t) throws ParseException, ServiceException, MailServiceException
    {
        switch(target) {
          case HAS:
                if (!tok.equalsIgnoreCase("attachment")) {
                    return new ZimbraQuery.HasQuery(mMailbox, mAnalyzer, modifier, tok);
            }
            tok = "any";
            // otherwise FALL THROUGH to AttachmentQuery below!
          case ATTACHMENT:
            return new ZimbraQuery.AttachmentQuery(mMailbox, mAnalyzer, modifier,tok);
          case TYPE:
            return new ZimbraQuery.TypeQuery(mMailbox, mAnalyzer, modifier,tok);
          case ITEM:
            return ZimbraQuery.ItemQuery.Create(mMailbox, mAnalyzer, modifier, tok);
          case UNDERID:
          case INID:
          {
              ItemId iid = null;
              int subfolderSplit = tok.indexOf('/');
              String iidStr;
              String subfolderPath = null;
              if (subfolderSplit > 0) {
                  iidStr = tok.substring(0, subfolderSplit);
                  subfolderPath = tok.substring(subfolderSplit+1);
              } else {
                  iidStr = tok;
              }
              iid = new ItemId(iidStr, (String)null);
              try {
                return ZimbraQuery.InQuery.Create(mMailbox, mAnalyzer, modifier, iid, subfolderPath, (target == UNDERID));
              } catch (ServiceException e) {
                  // bug: 18623 -- dangling mountpoints create problems with 'is:remote'
                              ZimbraLog.index.debug("Ignoring INID/UNDERID clause b/c of ServiceException: "+e);
                  return ZimbraQuery.InQuery.Create(mMailbox, mAnalyzer, modifier, ZimbraQuery.InQuery.IN_NO_FOLDER, false);
              }
          }
          case UNDER:
          case IN:
          {
              Integer folderId = sFolderStrMap.get(tok.toLowerCase());
              if (folderId != null) {
                  return ZimbraQuery.InQuery.Create(mMailbox, mAnalyzer, modifier, folderId, (target == UNDER));
              } else {
                  return ZimbraQuery.InQuery.Create(mMailbox, mAnalyzer, modifier, tok, (target == UNDER));
              }
          }
          case TAG:
            return new ZimbraQuery.TagQuery(mMailbox, mAnalyzer, modifier, tok, true);
          case IS:
            GetQueryCallback cback = sIsStrMap.get(tok.toLowerCase());
            if (cback != null) {
                return cback.execute(mMailbox, mAnalyzer, modifier);
            } else {
                throw parseException("Unknown text after is: in query string", "UNKNOWN_TEXT_AFTER_IS", t);
            }
          case CONV:
            return ZimbraQuery.ConvQuery.create(mMailbox, mAnalyzer, modifier, tok);
          case CONV_COUNT:
            return ZimbraQuery.ConvCountQuery.create(mMailbox, mAnalyzer, modifier, target, tok);
          case DATE:
          case DAY:
          case WEEK:
          case MONTH:
          case YEAR:
          case AFTER:
          case BEFORE:
          case CONV_START:
          case CONV_END:
          case APPT_START:
          case APPT_END:
          {
              ZimbraQuery.DateQuery q = new ZimbraQuery.DateQuery(mAnalyzer, target);
              q.parseDate(modifier, tok, t, mTimeZone, mLocale);
              return q;
          }
          case TOFROM:
          case TOCC:
          case FROMCC:
          case TOFROMCC:
                        if (tok == null || tok.length() < 1) {
                 throw parseException("Missing required text after a TO/FROM/CC", "MISSING_TEXT_AFTER_TOFROMCC", t);
                        }
                        return ZimbraQuery.AddrQuery.createFromTarget(mMailbox, mAnalyzer, modifier, target, tok);
          case FROM:
                        if (tok == null || tok.length() < 1) {
                 throw parseException("Missing required text after a TO/FROM/CC", "MISSING_TEXT_AFTER_TOFROMCC", t);
                        }
                        return ZimbraQuery.SenderQuery.create(mMailbox, mAnalyzer, modifier, target, tok);
          case TO:
          case ENVTO:
          case ENVFROM:
          case CC:
            if (tok == null || tok.length() < 1) {
                throw parseException("Missing required text after a TO/FROM/CC", "MISSING_TEXT_AFTER_TOFROMCC", t);
            }
            if (tok.charAt(0) == '@') {
                return new ZimbraQuery.DomainQuery(mMailbox, mAnalyzer, modifier, target, tok);
            }
            return new ZimbraQuery.TextQuery(mMailbox, mAnalyzer, modifier,target,tok);
          case MODSEQ:
            return new ZimbraQuery.ModseqQuery(mMailbox, mAnalyzer, modifier, target, tok);
          case SIZE:
          case BIGGER:
          case SMALLER:
            return new ZimbraQuery.SizeQuery(mAnalyzer, modifier,target,tok);
          case SUBJECT:
            return ZimbraQuery.SubjectQuery.create(mMailbox, mAnalyzer, modifier, target, tok);
          default:
            return new ZimbraQuery.TextQuery(mMailbox, mAnalyzer, modifier,target,tok);
        }
    }

    private Analyzer mAnalyzer = null;
    private Mailbox mMailbox = null;
    private TimeZone mTimeZone = null;
    private Locale mLocale = null;

        // the query string can OPTIONALLY have a "sortby:" element which will override the
        // sortBy specified in the <SearchRequest> xml...this is basically to allow people
        // to do more with cut-and-pasted search strings
    private String mSortByStr = null;
    public String getSortByStr() { return mSortByStr; }

    public void init(Analyzer analyzer, Mailbox mbx, TimeZone tz, Locale locale, int defaultField) {
       mAnalyzer = analyzer;
           mMailbox = mbx;
           mTimeZone = tz;
           mLocale = locale;
           mDefaultField = defaultField;
    }

    public ArrayList Parse() throws ServiceException, ParseException {
        try {
            return DoParse();
        } catch(TokenMgrError e) {
            Token t = new Token();
            t.image = "";
            t.beginColumn = e.colNo;
            t.endColumn = e.colNo;
            throw parseException(e.getMessage(), "LEXICAL_ERROR", t);
        }
    }

    public static final void AddClause(ArrayList clauses, ZimbraQuery.BaseQuery q)
    {
        if (null != q) {
            if (clauses.size() > 0) {
                ZimbraQuery.BaseQuery prev = (ZimbraQuery.BaseQuery)clauses.get(clauses.size()-1);
                assert(prev.getNext() == null);
                prev.setNext(q);
            }
            clauses.add(q);
        }
    }

//<QUOTED_STATE>SKIP:
//{
//    "\""  { SwitchTo(DEFAULT); } 
//}

//<QUOTED_STATE>TOKEN :
//{
//    <ERROR_QUOTE_WITH_NEWLINE: (["\n", "\r"])>  { SwitchTo(DEFAULT); }
//    |    <QUOTED_TOK: (~["\"","\n","\r"])+>
//}

//////////////////////////////////////////////////////////////////////
///
/// Parser States
///
  final public ZimbraQuery.BaseQuery Conjunction() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case AND_TOKEN:
      jj_consume_token(AND_TOKEN);
                    {if (true) return new ZimbraQuery.ConjQuery(mAnalyzer, AND_TOKEN);}
      break;
    case OR_TOKEN:
      jj_consume_token(OR_TOKEN);
                       {if (true) return new ZimbraQuery.ConjQuery(mAnalyzer, OR_TOKEN);}
      break;
    default:
      jj_la1[0] = jj_gen;
           {if (true) return new ZimbraQuery.ConjQuery(mAnalyzer, AND_TOKEN);}
    }
    throw new Error("Missing return statement in function");
  }

  final public int Modifier() throws ParseException {
    Token mod = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PLUS:
      jj_consume_token(PLUS);
             {if (true) return PLUS;}
      break;
    case MINUS:
      jj_consume_token(MINUS);
                 {if (true) return MINUS;}
      break;
    case NOT_TOKEN:
      jj_consume_token(NOT_TOKEN);
                     {if (true) return MINUS;}
      break;
    default:
      jj_la1[1] = jj_gen;

        {if (true) return 0;}
    }
    throw new Error("Missing return statement in function");
  }

  final public int DateModifier() throws ParseException {
    Token mod = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NOT_TOKEN:
      jj_consume_token(NOT_TOKEN);
                  {if (true) return NOT_TOKEN;}
      break;
    default:
      jj_la1[2] = jj_gen;

        {if (true) return 0;}
    }
    throw new Error("Missing return statement in function");
  }

  final public void SortBy() throws ParseException {
    Token t = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SORTBY:
    case SORT:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SORTBY:
        jj_consume_token(SORTBY);
        break;
      case SORT:
        jj_consume_token(SORT);
        break;
      default:
        jj_la1[3] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      t = jj_consume_token(TEXT_TOK);
                                    mSortByStr = t.image;
      break;
    default:
      jj_la1[4] = jj_gen;

    }
  }

/***
 *
 * Text target but after we have a target (thing to the left of the :...)
 *
 **/
  final public ZimbraQuery.BaseQuery Rhs_Text(int target) throws ParseException, ServiceException {
    ArrayList clauses = new ArrayList();
    Token t;
    int modifier = 0;
    ZimbraQuery.BaseQuery clause = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LPAREN:
      jj_consume_token(LPAREN);
      modifier = Modifier();
      clause = Rhs_Text(target);
                                                               clause.setModifier(modifier);  AddClause(clauses,clause);
      label_1:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case AND_TOKEN:
        case OR_TOKEN:
        case NOT_TOKEN:
        case LPAREN:
        case PLUS:
        case MINUS:
        case QUOTED_TOK:
        case TEXT_TOK:
          ;
          break;
        default:
          jj_la1[5] = jj_gen;
          break label_1;
        }
        clause = Conjunction();
                                   AddClause(clauses,clause);
        modifier = Modifier();
        clause = Rhs_Text(target);
                                                          clause.setModifier(modifier); AddClause(clauses,clause);
      }
      jj_consume_token(RPAREN);
                   {if (true) return new ZimbraQuery.SubQuery(mAnalyzer, 0,clauses);}
      break;
    case QUOTED_TOK:
    case TEXT_TOK:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TEXT_TOK:
        t = jj_consume_token(TEXT_TOK);
        break;
      case QUOTED_TOK:
        t = jj_consume_token(QUOTED_TOK);
        break;
      default:
        jj_la1[6] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
                                       {if (true) return GetQuery(modifier, target, t.image, t);}
      break;
    default:
      jj_la1[7] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

/***
 *
 * item:  target
 *
 * Like Rhs_Text, except we allow {}'s, so these are legal:
 *   'item:{1,2,3}', 'item:({1,2,3} or {4,5,6})'
 *
 **/
  final public ZimbraQuery.BaseQuery Rhs_Item(int target) throws ParseException, ServiceException {
    ArrayList clauses = new ArrayList();
    Token t;
    int modifier = 0;
    ZimbraQuery.BaseQuery clause = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LPAREN:
      jj_consume_token(LPAREN);
      modifier = Modifier();
      clause = Rhs_Item(target);
                                                               clause.setModifier(modifier);  AddClause(clauses,clause);
      label_2:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case AND_TOKEN:
        case OR_TOKEN:
        case NOT_TOKEN:
        case LPAREN:
        case PLUS:
        case MINUS:
        case QUOTED_TOK:
        case TEXT_TOK:
        case BRACES_TOK:
          ;
          break;
        default:
          jj_la1[8] = jj_gen;
          break label_2;
        }
        clause = Conjunction();
                                   AddClause(clauses,clause);
        modifier = Modifier();
        clause = Rhs_Item(target);
                                                          clause.setModifier(modifier); AddClause(clauses,clause);
      }
      jj_consume_token(RPAREN);
                   {if (true) return new ZimbraQuery.SubQuery(mAnalyzer, 0,clauses);}
      break;
    case QUOTED_TOK:
    case TEXT_TOK:
    case BRACES_TOK:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TEXT_TOK:
        t = jj_consume_token(TEXT_TOK);
        break;
      case QUOTED_TOK:
        t = jj_consume_token(QUOTED_TOK);
        break;
      case BRACES_TOK:
        t = jj_consume_token(BRACES_TOK);
        break;
      default:
        jj_la1[9] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
                                                      {if (true) return GetQuery(modifier, target, t.image, t);}
      break;
    default:
      jj_la1[10] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

/***
 *
 * Like Rhs_Text but allows field parameter for field:
 *
 **/
  final public ZimbraQuery.BaseQuery Rhs_Field(int target, String img) throws ParseException, ServiceException {
    ArrayList clauses = new ArrayList();
    Token t;
    int modifier = 0;
    ZimbraQuery.BaseQuery clause = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LPAREN:
      jj_consume_token(LPAREN);
      modifier = Modifier();
      clause = Rhs_Field(target, img);
                                                                     clause.setModifier(modifier);  AddClause(clauses,clause);
      label_3:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case AND_TOKEN:
        case OR_TOKEN:
        case NOT_TOKEN:
        case LPAREN:
        case PLUS:
        case MINUS:
        case QUOTED_TOK:
        case TEXT_TOK:
          ;
          break;
        default:
          jj_la1[11] = jj_gen;
          break label_3;
        }
        clause = Conjunction();
                                   AddClause(clauses,clause);
        modifier = Modifier();
        clause = Rhs_Field(target, img);
                                                                clause.setModifier(modifier); AddClause(clauses,clause);
      }
      jj_consume_token(RPAREN);
                   {if (true) return new ZimbraQuery.SubQuery(mAnalyzer, 0,clauses);}
      break;
    case QUOTED_TOK:
    case TEXT_TOK:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TEXT_TOK:
        t = jj_consume_token(TEXT_TOK);
        break;
      case QUOTED_TOK:
        t = jj_consume_token(QUOTED_TOK);
        break;
      default:
        jj_la1[12] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
                                       {if (true) return GetFieldQuery(modifier, target, img, t.image);}
      break;
    default:
      jj_la1[13] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

/***
 *
 * special date target (because dates allow starting - (minus) signs, and we don't want to interpret those as a NOT, like
 * we do in other cases
 *
 **/
  final public ZimbraQuery.BaseQuery Rhs_Date(int target) throws ParseException, ServiceException {
    ArrayList clauses = new ArrayList();
    Token t,u;
    int modifier = 0;
    ZimbraQuery.BaseQuery clause = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LPAREN:
      jj_consume_token(LPAREN);
      modifier = DateModifier();
      clause = Rhs_Date(target);
                                                                   if (modifier == NOT_TOKEN) { clause.setModifier(MINUS); } AddClause(clauses,clause);
      label_4:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case AND_TOKEN:
        case OR_TOKEN:
        case NOT_TOKEN:
        case LPAREN:
        case PLUS:
        case MINUS:
        case QUOTED_TOK:
        case TEXT_TOK:
          ;
          break;
        default:
          jj_la1[14] = jj_gen;
          break label_4;
        }
        clause = Conjunction();
                                   AddClause(clauses,clause);
        modifier = DateModifier();
        clause = Rhs_Date(target);
                                                              if (modifier == NOT_TOKEN) { clause.setModifier(MINUS); } AddClause(clauses,clause);
      }
      jj_consume_token(RPAREN);
                   {if (true) return new ZimbraQuery.SubQuery(mAnalyzer, 0,clauses);}
      break;
    case PLUS:
    case MINUS:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MINUS:
        u = jj_consume_token(MINUS);
        break;
      case PLUS:
        u = jj_consume_token(PLUS);
        break;
      default:
        jj_la1[15] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TEXT_TOK:
        t = jj_consume_token(TEXT_TOK);
        break;
      case QUOTED_TOK:
        t = jj_consume_token(QUOTED_TOK);
        break;
      default:
        jj_la1[16] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
                                                           {if (true) return GetQuery(0, target, u.image+t.image, t);}
      break;
    case QUOTED_TOK:
    case TEXT_TOK:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TEXT_TOK:
        t = jj_consume_token(TEXT_TOK);
        break;
      case QUOTED_TOK:
        t = jj_consume_token(QUOTED_TOK);
        break;
      default:
        jj_la1[17] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
                                       {if (true) return GetQuery(0, target, t.image, t);}
      break;
    default:
      jj_la1[18] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

//////////////////////////////
//
// Main grammar
//
  final public ZimbraQuery.BaseQuery Clause() throws ParseException, ServiceException {
    Token t = null;

    ZimbraQuery.BaseQuery q = null;
    ArrayList subExp = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LPAREN:
      jj_consume_token(LPAREN);
      subExp = Query();
      jj_consume_token(RPAREN);
                                       {if (true) return new ZimbraQuery.SubQuery(mAnalyzer, 0, subExp);}
      break;
    case QUOTED_TOK:
    case TEXT_TOK:
    case CONTENT:
    case SUBJECT:
    case MSGID:
    case ENVTO:
    case ENVFROM:
    case CONTACT:
    case TO:
    case FROM:
    case CC:
    case TOFROM:
    case TOCC:
    case FROMCC:
    case TOFROMCC:
    case IN:
    case UNDER:
    case INID:
    case UNDERID:
    case HAS:
    case FILENAME:
    case TYPE:
    case ATTACHMENT:
    case IS:
    case DATE:
    case DAY:
    case WEEK:
    case MONTH:
    case YEAR:
    case AFTER:
    case BEFORE:
    case SIZE:
    case BIGGER:
    case SMALLER:
    case TAG:
    case MESSAGE:
    case MY:
    case MODSEQ:
    case CONV:
    case CONV_COUNT:
    case CONV_MINM:
    case CONV_MAXM:
    case CONV_START:
    case CONV_END:
    case APPT_START:
    case APPT_END:
    case AUTHOR:
    case TITLE:
    case KEYWORDS:
    case COMPANY:
    case METADATA:
    case ITEM:
    case FIELD:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CONTENT:
      case SUBJECT:
      case MSGID:
      case ENVTO:
      case ENVFROM:
      case CONTACT:
      case TO:
      case FROM:
      case CC:
      case TOFROM:
      case TOCC:
      case FROMCC:
      case TOFROMCC:
      case IN:
      case UNDER:
      case INID:
      case UNDERID:
      case HAS:
      case FILENAME:
      case TYPE:
      case ATTACHMENT:
      case IS:
      case SIZE:
      case BIGGER:
      case SMALLER:
      case TAG:
      case MESSAGE:
      case MY:
      case MODSEQ:
      case CONV:
      case CONV_COUNT:
      case CONV_MINM:
      case CONV_MAXM:
      case AUTHOR:
      case TITLE:
      case KEYWORDS:
      case COMPANY:
      case METADATA:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case MSGID:
          t = jj_consume_token(MSGID);
          break;
        case ENVFROM:
          t = jj_consume_token(ENVFROM);
          break;
        case ENVTO:
          t = jj_consume_token(ENVTO);
          break;
        case FROM:
          t = jj_consume_token(FROM);
          break;
        case TO:
          t = jj_consume_token(TO);
          break;
        case CC:
          t = jj_consume_token(CC);
          break;
        case CONTACT:
          t = jj_consume_token(CONTACT);
          break;
        case TOFROM:
          t = jj_consume_token(TOFROM);
          break;
        case TOCC:
          t = jj_consume_token(TOCC);
          break;
        case FROMCC:
          t = jj_consume_token(FROMCC);
          break;
        case TOFROMCC:
          t = jj_consume_token(TOFROMCC);
          break;
        case CONTENT:
          t = jj_consume_token(CONTENT);
          break;
        case MESSAGE:
          t = jj_consume_token(MESSAGE);
          break;
        case SUBJECT:
          t = jj_consume_token(SUBJECT);
          break;
        case IN:
          t = jj_consume_token(IN);
          break;
        case INID:
          t = jj_consume_token(INID);
          break;
        case UNDER:
          t = jj_consume_token(UNDER);
          break;
        case UNDERID:
          t = jj_consume_token(UNDERID);
          break;
        case TYPE:
          t = jj_consume_token(TYPE);
          break;
        case ATTACHMENT:
          t = jj_consume_token(ATTACHMENT);
          break;
        case HAS:
          t = jj_consume_token(HAS);
          break;
        case FILENAME:
          t = jj_consume_token(FILENAME);
          break;
        case AUTHOR:
          t = jj_consume_token(AUTHOR);
          break;
        case TITLE:
          t = jj_consume_token(TITLE);
          break;
        case KEYWORDS:
          t = jj_consume_token(KEYWORDS);
          break;
        case COMPANY:
          t = jj_consume_token(COMPANY);
          break;
        case METADATA:
          t = jj_consume_token(METADATA);
          break;
        case MY:
          t = jj_consume_token(MY);
          break;
        case IS:
          t = jj_consume_token(IS);
          break;
        case TAG:
          t = jj_consume_token(TAG);
          break;
        case CONV:
          t = jj_consume_token(CONV);
          break;
        case CONV_COUNT:
          t = jj_consume_token(CONV_COUNT);
          break;
        case CONV_MINM:
          t = jj_consume_token(CONV_MINM);
          break;
        case CONV_MAXM:
          t = jj_consume_token(CONV_MAXM);
          break;
        case SIZE:
          t = jj_consume_token(SIZE);
          break;
        case BIGGER:
          t = jj_consume_token(BIGGER);
          break;
        case SMALLER:
          t = jj_consume_token(SMALLER);
          break;
        case MODSEQ:
          t = jj_consume_token(MODSEQ);
          break;
        default:
          jj_la1[19] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        q = Rhs_Text(t.kind);
        break;
      case FIELD:
        t = jj_consume_token(FIELD);
        q = Rhs_Field(t.kind, t.image);
        break;
      case ITEM:
        t = jj_consume_token(ITEM);
        q = Rhs_Item(t.kind);
        break;
      case DATE:
      case DAY:
      case WEEK:
      case MONTH:
      case YEAR:
      case AFTER:
      case BEFORE:
      case CONV_START:
      case CONV_END:
      case APPT_START:
      case APPT_END:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case DATE:
          t = jj_consume_token(DATE);
          break;
        case DAY:
          t = jj_consume_token(DAY);
          break;
        case MONTH:
          t = jj_consume_token(MONTH);
          break;
        case WEEK:
          t = jj_consume_token(WEEK);
          break;
        case YEAR:
          t = jj_consume_token(YEAR);
          break;
        case AFTER:
          t = jj_consume_token(AFTER);
          break;
        case BEFORE:
          t = jj_consume_token(BEFORE);
          break;
        case CONV_START:
          t = jj_consume_token(CONV_START);
          break;
        case CONV_END:
          t = jj_consume_token(CONV_END);
          break;
        case APPT_START:
          t = jj_consume_token(APPT_START);
          break;
        case APPT_END:
          t = jj_consume_token(APPT_END);
          break;
        default:
          jj_la1[20] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        q = Rhs_Date(t.kind);
        break;
      case QUOTED_TOK:
      case TEXT_TOK:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case TEXT_TOK:
          t = jj_consume_token(TEXT_TOK);
          break;
        case QUOTED_TOK:
          t = jj_consume_token(QUOTED_TOK);
          break;
        default:
          jj_la1[21] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
                                          {if (true) return GetQuery(0,mDefaultField,t.image, t);}
        break;
      default:
        jj_la1[22] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
       {if (true) return q;}
      break;
    default:
      jj_la1[23] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public ArrayList Query() throws ParseException, ServiceException {
    ZimbraQuery.BaseQuery clause = null;
    ArrayList clauses = new ArrayList();
    int modifier;
    SortBy();
    modifier = Modifier();
    clause = Clause();
    SortBy();
                                                            if (clause != null) { clause.setModifier(modifier); AddClause(clauses,clause); }
    label_5:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case AND_TOKEN:
      case OR_TOKEN:
      case NOT_TOKEN:
      case LPAREN:
      case PLUS:
      case MINUS:
      case QUOTED_TOK:
      case TEXT_TOK:
      case CONTENT:
      case SUBJECT:
      case MSGID:
      case ENVTO:
      case ENVFROM:
      case CONTACT:
      case TO:
      case FROM:
      case CC:
      case TOFROM:
      case TOCC:
      case FROMCC:
      case TOFROMCC:
      case IN:
      case UNDER:
      case INID:
      case UNDERID:
      case HAS:
      case FILENAME:
      case TYPE:
      case ATTACHMENT:
      case IS:
      case DATE:
      case DAY:
      case WEEK:
      case MONTH:
      case YEAR:
      case AFTER:
      case BEFORE:
      case SIZE:
      case BIGGER:
      case SMALLER:
      case TAG:
      case MESSAGE:
      case MY:
      case MODSEQ:
      case CONV:
      case CONV_COUNT:
      case CONV_MINM:
      case CONV_MAXM:
      case CONV_START:
      case CONV_END:
      case APPT_START:
      case APPT_END:
      case AUTHOR:
      case TITLE:
      case KEYWORDS:
      case COMPANY:
      case METADATA:
      case ITEM:
      case FIELD:
        ;
        break;
      default:
        jj_la1[24] = jj_gen;
        break label_5;
      }
      clause = Conjunction();
                               AddClause(clauses,clause);
      modifier = Modifier();
      clause = Clause();
                                              if (clause != null) { clause.setModifier(modifier); AddClause(clauses,clause); }
      SortBy();
    }

        {if (true) return clauses;}
    throw new Error("Missing return statement in function");
  }

  final public ArrayList DoParse() throws ParseException, ServiceException {
    ArrayList clauses;
    clauses = Query();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 0:
    case 76:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 76:
        jj_consume_token(76);
        break;
      case 0:
        jj_consume_token(0);
        break;
      default:
        jj_la1[25] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      jj_la1[26] = jj_gen;
      ;
    }
        {if (true) return clauses;}
    throw new Error("Missing return statement in function");
  }

  public ZimbraQueryParserTokenManager token_source;
  JavaCharStream jj_input_stream;
  public Token token, jj_nt;
  private int jj_ntk;
  private int jj_gen;
  final private int[] jj_la1 = new int[27];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static private int[] jj_la1_2;
  static {
      jj_la1_0();
      jj_la1_1();
      jj_la1_2();
   }
   private static void jj_la1_0() {
      jj_la1_0 = new int[] {0x30,0x640,0x40,0x0,0x0,0x36f0,0x3000,0x3080,0x36f0,0x3000,0x3080,0x36f0,0x3000,0x3080,0x36f0,0x600,0x3000,0x3000,0x3680,0xffff0000,0x0,0x3000,0xffff3000,0xffff3080,0xffff36f0,0x1,0x1,};
   }
   private static void jj_la1_1() {
      jj_la1_1 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xc3fe603f,0x3c001fc0,0x0,0xfffe7fff,0xfffe7fff,0xfffe7fff,0x0,0x0,};
   }
   private static void jj_la1_2() {
      jj_la1_2 = new int[] {0x0,0x0,0x0,0x30,0x30,0x0,0x0,0x0,0x800,0x800,0x800,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x7,0x0,0x0,0x4f,0x4f,0x4f,0x1000,0x1000,};
   }

  public ZimbraQueryParser(java.io.InputStream stream) {
     this(stream, null);
  }
  public ZimbraQueryParser(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new JavaCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new ZimbraQueryParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 27; i++) jj_la1[i] = -1;
  }

  public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 27; i++) jj_la1[i] = -1;
  }

  public ZimbraQueryParser(java.io.Reader stream) {
    jj_input_stream = new JavaCharStream(stream, 1, 1);
    token_source = new ZimbraQueryParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 27; i++) jj_la1[i] = -1;
  }

  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 27; i++) jj_la1[i] = -1;
  }

  public ZimbraQueryParser(ZimbraQueryParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 27; i++) jj_la1[i] = -1;
  }

  public void ReInit(ZimbraQueryParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 27; i++) jj_la1[i] = -1;
  }

  final private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

  final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  final private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.Vector jj_expentries = new java.util.Vector();
  private int[] jj_expentry;
  private int jj_kind = -1;

  public ParseException generateParseException() {
    jj_expentries.removeAllElements();
    boolean[] la1tokens = new boolean[77];
    for (int i = 0; i < 77; i++) {
      la1tokens[i] = false;
    }
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 27; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
          if ((jj_la1_2[i] & (1<<j)) != 0) {
            la1tokens[64+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 77; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.addElement(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = (int[])jj_expentries.elementAt(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  final public void enable_tracing() {
  }

  final public void disable_tracing() {
  }

}
